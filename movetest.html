<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="interface.js"></script>
    <title>Document</title>
</head>

<body>
    <script>
        function HIcan(w, h, _scale) {
            var can = document.createElement('canvas')

            _scale = (!_scale) || window.devicePixelRatio / (can.getContext('2d').backingStorePixelRatio || 1);
            can.width = w * _scale;
            can.height = h * _scale;
            can.style.width = w + "px";
            can.style.height = h + "px";
            can.getContext("2d").scale(_scale, _scale);

            document.body.appendChild(can);

            return can;
        }

        var canvas = HIcan(320, 320, 3)
        var ctx = canvas.getContext('2d')

        function moveTowards(t, p) {
            var dx = Math.atan2(t.x - p.x),
                dy = Math.atan2(t.y - p.y),
                moveX = Math.cos(dx),
                moveY = Math.sin(dy);

            return {
                x: moveX,
                y: moveY
            }
        }

        function Enemy(_x, _y) {
            this.x = _x;
            this.y = _y;
            this.w = 5;
            this.h = 5;

            this.move = function (_point) {

                var movePos = moveTowards(this, _point)
                this.x += movePos.x
                this.y += movePos.y

            }
        }

        var enemies = []
        enemies.push(new Enemy(100, 80))
        enemies.push(new Enemy(100, 160))

        var point = {
            x: 200,
            y: 100
        }

        // function drawFPS() {
        //     var current = Date.now();
        //     frameC++

        //     if (current - elapsed >= 100) {
        //         console.log('ok')
        //         avgFPS = frameC / (current - start)
        //         elapsed = current
        //     }

        //     ctx.fillStyle = 'white  '
        //     ctx.font = '16px Impact'
        //     ctx.fillText(parseInt(avgFPS * 1000), 5, 20)
        //     ctx.strokeStyle = 'black'
        //     ctx.strokeText(parseInt(avgFPS * 1000), 5, 20);
        // }

        var mousePos = {
            x: 0,
            y: 0,
            w: 1,
            h: 1
        }

        document.onmousemove = function (evt) {
            var cRect = canvas.getBoundingClientRect();
            mousePos.x = evt.clientX - cRect.x
            mousePos.y = evt.clientY - cRect.y
        }

        document.onclick = function (evt) {
            towers.push(new Tower(mousePos.x, mousePos.y))
        }

        function rectCollision(rect1, rect2) {
            if (rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y) {
                return true;
            } else {
                return false;
            }
        }

        function Point(_x, _y, _size) {
            this.x = _x;
            this.y = _y;
            this.w = _size;
            this.h = _size;
        }

        var bullets = [];

        function Bullet(_x, _y, _target) {
            this.x = _x;
            this.y = _y;
            this.w = 5;
            this.h = 5;

            this.update = function () {
                this.angle = angleD(_target, this)
                this.x += Math.cos(this.angle)
                this.y += Math.sin(this.angle)
                ctx.fillText(this.angle, this.x, this.y)
            }
        }

        var gravity = 0.7;
        var friction = 0.5;

        function AABB() {

        }

        function Player(_x, _y, _size) {
            this.x = _x;
            this.y = _y;

            // this.footSens =

                this.velX = 0;
            this.velY = 0;

            this.w = _size;
            this.h = _size;

            this.speed = 2
            this.jumpForce = 8

            this.jumping = true;
        }

        Player.prototype.move = function (dirx, diry) {

            if (dirx == 1) {
                this.velX += this.speed
            }
            if (dirx == -1) {
                this.velX -= this.speed
            }
            if (diry == 1) {
                this.velY += this.speed
            }
            if (diry == -1) {
                if (!this.jumping) {
                    this.velY -= this.jumpForce;
                }
            }

            // Check with Borders for X
            if (this.x !== 0) {
                this.x += this.velX;
            }
            if (this.x < 512) {
                this.x += this.velX
            }

            if (this.x + this.w > 512) {
                this.x--;
            }
            if (this.x < 0) {
                this.x = 0;
            }

            // Check for Borders with Y
            if (this.x !== 0) {
                this.x += this.velX;
            }
            if (this.x < 512) {
                this.x += this.velX
            }

            if (this.x + this.w > 512) {
                this.x--;
            }
            if (this.x < 0) {
                this.x = 0;
            }

            this.velY += gravity

            this.y += this.velY

            this.velX *= friction
            this.velY *= gravity;

        }

        Player.prototype.pushBack = function (_dir) {
            if (_dir == 'down') {
                this.y -= 1
            }
            if (_dir == 'up') {
                this.y += 1
            }
            if (_dir == 'left') {
                this.x += 1
            }
            if (_dir == 'right') {
                this.x -= 1
            }
        }

        var plr = new Player(150, 50, 5)

        var points = [];
        // points.push(new Point(50, 150, 10))
        // points.push(new Point(150, 50, 10))

        function Tower(_x, _y) {
            this.x = _x;
            this.y = _y;
            this.w = 20;
            this.h = 20
            this.target = points[0] || undefined

            this.shootTick = 60;
            this.sTick = 0;

            this.ang = 0;

            this.update = function () {
                if (this.target) {
                    this.ang = angleD(this.target, this)
                    if (this.sTick >= this.shootTick) {
                        this.target = points[0];
                        this.ang = angleD(this.target, this)

                        bullets.push(new Bullet(this.x, this.y, this.target))
                        this.sTick = 0;
                        console.log('shooting at angle', this.ang)
                    }
                }
                this.sTick++;
            }
        }

        function angleD(a, b, _type) {
            var theta = Math.atan2((b.y - a.y) - (b.x - a.x)) * 180 / Math.PI
            return (theta < 0) ? 360 + theta : theta;
        }

        var towers = [];
        document.onclick = function (evt) {
            towers.push(new Tower(mousePos.x, mousePos.y))
        }

        var keys = [];
        document.onkeydown = function (evt) {
            keys[evt.key] = true
            console.log(evt.key)
        }

        document.onkeyup = function (evt) {
            keys[evt.key] = false
        }

        function distance(p1, p2) {
            var dx = p2.x - p1.x
            var dy = p2.y - p1.y
            return Math.sqrt(dx * dx + dy * dy);
        }

        function Platform(_x, _y, _w, _h) {
            this.x = _x;
            this.y = _y;
            this.w = _w;
            this.h = _h;
        }

        var platforms = [];

        platforms.push(new Platform(50, 100, 200, 5))

        update()

        function update() {
            requestAnimationFrame(update)

            // Put your drawing code here
            ctx.clearRect(0, 0, 320, 320)

            ctx.fillStyle = 'lightgray'
            ctx.fillRect(0, 0, 320, 320)

            ctx.fillStyle = 'red'
            enemies.forEach(e => {
                e.move(point, e)
                ctx.fillRect(e.x, e.y, e.w, e.h)

            })


            if (keys['s']) {
                plr.move(0, 1)
            }
            if (keys['w']) {
                plr.move(0, -1)
            }
            if (keys['d']) {
                plr.move(1, 0)
            }
            if (keys['a']) {
                plr.move(-1, 0)
                // console.log('a')
            }

            if (keys[' ']) {
                ctx.strokeStyle = 'red'
                ctx.moveTo(points[0].x, points[0].y)
                ctx.lineTo(points[1].x, points[1].y)
                ctx.stroke()
            }


            platforms.forEach(function (p, _index) {
                ctx.fillStyle = 'black'
                ctx.fillRect(p.x, p.y, p.w, p.h)

                if (rectCollision(p, plr)) {
                    plr.jumping = false;
                    // plr.pushBack('down')
                    plr.y--;
                    console.log('y')
                }
            })


            plr.move()


            towers.forEach(t => {
                t.update()
                ctx.fillStyle = 'black'
                ctx.fillRect(t.x, t.y, t.w, t.h)
            })

            bullets.forEach(b => {
                b.update()
                ctx.fillStyle = 'purple'
                ctx.fillRect(b.x, b.y, b.w, b.h)
            })


            // Drawing 
            points.forEach(p => {
                ctx.fillStyle = 'red'
                ctx.fillRect(p.x, p.y, p.w, p.h)
            })


            // var tAng = getSlopeAngle(points[1], points[0])

            // console.log(tAng)
            // for(var i = points[0].x)

            ctx.fillStyle = 'red'
            ctx.fillRect(plr.x, plr.y, plr.w, plr.h)

            // ctx.fillStyle = 'green'
            // ctx.fillText(distance(towers[0], points[0]), 15, 15)

        }

        function getSlopeAngle(s1, s2) {
            return Math.atan((s2.y - s1.y) / (s2.x - s1.x)) * 180 / Math.PI;
        }
    </script>
</body>

</html>